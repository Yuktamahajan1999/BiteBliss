import Order from "../Models/Order.js";
import DeliveryPartner from "../Models/DeliveryPartner.js";
import Restaurant from "../Models/Restaurant.js";
import Recommendation from "../Models/Recommedations.js";
import mongoose from "mongoose";

const statusToStage = {
  pending: 1,
  restaurant_accepted: 2,
  preparing: 3,
  ready_for_pickup: 4,
  arrived: 5,
  "out for delivery": 6,
  delivered: 7,
  cancelled: 0
};

export const createOrder = async (req, res) => {
  try {
    const restaurant = await Restaurant.findById(req.body.restaurantId);
    if (!restaurant) return res.status(404).json({ message: "Restaurant not found" });

    if (!restaurant.isOpen) {
      return res.status(400).json({
        message: restaurant.closureReason || "Restaurant is currently closed"
      });
    }

    if (req.body.orderType === 'delivery') {
      if (!restaurant.deliveryAvailable) {
        return res.status(400).json({
          message: restaurant.deliveryUnavailableReason || "Delivery unavailable"
        });
      }
      if (!restaurant.acceptingOrders) {
        return res.status(400).json({ message: "Not accepting orders" });
      }
    } else if (req.body.orderType === 'dining' && !restaurant.acceptingBookings) {
      return res.status(400).json({ message: "Not accepting bookings" });
    } else if (req.body.orderType === 'train' && !restaurant.deliveryAvailable) {
      return res.status(400).json({ message: "Train delivery unavailable" });
    }

    const { restaurantName, restaurantLocation, restaurantId, items, paymentMethod,
      totalAmount, addressId, gst, deliveryFee, payment, orderType } = req.body;

    if (!restaurantId || !Array.isArray(items) || items.length === 0 || !addressId) {
      return res.status(400).json({ error: "Invalid input data" });
    }

    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      const order = new Order({
        userId: req.userId,
        restaurantName,
        restaurantId,
        restaurantLocation,
        items,
        payment,
        paymentMethod,
        totalAmount,
        address: addressId,
        isFreeDelivery: Number(deliveryFee) === 0,
        gst,
        deliveryFee,
        status: "pending",
        orderPlacedTime: new Date(),
        isTrainOrder: orderType === 'train',
        orderType
      });

      await order.save({ session });

      if (orderType === 'train') {
        const { pnrNumber, trainNumber, stationName, mealType, specialRequest } = req.body;
        const trainOrder = new OrderOnTrain({
          orderNumber: `TRN-${Date.now()}`,
          orderId: order._id,
          userId: req.userId,
          restaurantId,
          pnrNumber,
          trainNumber,
          stationName,
          mealType,
          specialRequest: specialRequest || "",
          status: "Pending"
        });
        await trainOrder.save({ session });
        order.trainOrderRef = trainOrder._id;
        await order.save({ session });
      }

      const existingRec = await Recommendation.findOne({
        userId: req.userId,
        restaurantId
      }).session(session);

      if (!existingRec) {
        await new Recommendation({
          userId: req.userId,
          restaurantId,
          liked: false,
          recommendedBy: req.userId,
          autoGenerated: true
        }).save({ session });
      }

      await session.commitTransaction();
      res.status(201).json({
        message: "Order created successfully",
        order,
        ...(orderType === 'train' && { trainOrder })
      });
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};
export const getAllOrders = async (req, res) => {
  try {
    const orders = req.userRole === "restaurant"
      ? await Order.find({ restaurantName: req.userName })
        .populate('address')
      : await Order.find()
        .populate('address');
    res.status(200).json(orders);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

export const getOrderById = async (req, res) => {
  try {
    const { id } = req.query;

    if (!id) {
      return res.status(400).json({ error: "Order ID is required in query" });
    }

    if (!mongoose.isValidObjectId(id)) {
      return res.status(400).json({ error: "Invalid Order ID format" });
    }

    const order = await Order.findById(id)
      .populate('userId', 'name email phone')
      .populate('deliveryPartner', 'name phone vehicleId status averageRating')
      .populate('restaurantId', 'name location')
      .populate('address');
    if (!order) {
      return res.status(404).json({ error: "Order not found" });
    }

    if (req.userRole === "user" && order.userId.toString() !== req.userId) {
      return res.status(403).json({ error: "Access denied: not your order" });
    }

    return res.status(200).json(order);
  } catch (error) {
    return res.status(500).json({ error: error.message });
  }
};

export const updateOrderStatus = async (req, res) => {
  try {
    const { id } = req.query;
    const { status, cancellationReason, updatedBy } = req.body;

    if (!id) return res.status(400).json({ error: "Order ID required" });
    if (!mongoose.isValidObjectId(id)) {
      return res.status(400).json({ error: "Invalid Order ID format" });
    }

    const statusMappings = {
      pending: { stage: 1, next: ['restaurant_accepted', 'cancelled'] },
      restaurant_accepted: { stage: 2, next: ['preparing', 'cancelled'] },
      preparing: { stage: 3, next: ['ready_for_pickup', 'cancelled'] },
      ready_for_pickup: { stage: 4, next: ['out_for_delivery', 'cancelled'] },
      out_for_delivery: { stage: 5, next: ['delivered'] },
      delivered: { stage: 6, next: [] },
      cancelled: { stage: 0, next: [] }
    };

    const normalizedStatus = status?.toLowerCase().replace(/\s+/g, '_');
    if (!statusMappings[normalizedStatus]) {
      return res.status(400).json({ error: "Invalid status" });
    }

    const order = await Order.findById(id)
      .populate('userId', 'name email phone')
      .populate('deliveryPartner', 'name phone vehicleId status')
      .populate('address');

    if (!order) return res.status(404).json({ error: "Order not found" });

    const currentStatus = order.status?.toLowerCase().replace(/\s+/g, '_');
    if (!statusMappings[currentStatus]?.next.includes(normalizedStatus)) {
      return res.status(400).json({ error: "Invalid status transition" });
    }

    const updateData = {
      status: normalizedStatus,
      deliveryStage: statusMappings[normalizedStatus].stage,
      updatedBy,
      ...(normalizedStatus === 'cancelled' && {
        cancellationReason: cancellationReason || "No reason provided",
        cancelledAt: new Date()
      }),
      ...(normalizedStatus === 'restaurant_accepted' && { acceptedAt: new Date() }),
      ...(normalizedStatus === 'preparing' && { startedPreparingAt: new Date() }),
      ...(normalizedStatus === 'ready_for_pickup' && { readyAt: new Date() }),
      ...(normalizedStatus === 'out_for_delivery' && { dispatchedAt: new Date() }),
      ...(normalizedStatus === 'delivered' && { deliveredAt: new Date() })
    };

    const updatedOrder = await Order.findByIdAndUpdate(id, updateData, { new: true })
      .populate('userId', 'name email phone')
      .populate('deliveryPartner', 'name phone vehicleId status')
      .populate('address');

    res.status(200).json({
      success: true,
      message: "Order status updated",
      order: updatedOrder
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

export const deleteOrder = async (req, res) => {
  try {
    const { id } = req.query;
    if (!id) return res.status(400).json({ error: "Order ID required" });
    if (!mongoose.isValidObjectId(id)) {
      return res.status(400).json({ error: "Invalid Order ID format" });
    }

    const order = await Order.findById(id);
    if (!order) return res.status(404).json({ error: "Order not found" });
    if (req.userRole !== "user" || order.userId.toString() !== req.userId) {
      return res.status(403).json({ error: "Access denied" });
    }

    await Order.findByIdAndDelete(id);
    res.status(200).json({ message: "Order deleted" });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

export const getOrdersByRestaurant = async (req, res) => {
  try {
    const { id } = req.query;
    if (!id) return res.status(400).json({ error: "Restaurant ID required" });
    if (!mongoose.isValidObjectId(id)) {
      return res.status(400).json({ error: "Invalid Restaurant ID format" });
    }

    const restaurant = await Restaurant.findById(id);
    if (!restaurant) return res.status(404).json({ error: "Restaurant not found" });

    const orders = await Order.find({ restaurantId: id })
      .populate({
        path: 'deliveryPartner',
        select: 'name phone email vehicleId averageRating status'
      })
      .populate('address')
      .populate('payment')
      .populate({
        path: 'userId',
        select: 'name phone email'
      });

    res.status(200).json(orders);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

export const assignDeliveryPartner = async (req, res) => {
  try {
    const { orderId, deliveryPartnerId } = req.query;
    if (!orderId || !deliveryPartnerId) {
      return res.status(400).json({ error: "Both IDs required" });
    }
    if (!mongoose.isValidObjectId(orderId) || !mongoose.isValidObjectId(deliveryPartnerId)) {
      return res.status(400).json({ error: "Invalid ID format" });
    }

    const [order, partner] = await Promise.all([
      Order.findById(orderId),
      DeliveryPartner.findById(deliveryPartnerId)
    ]);

    if (!order) return res.status(404).json({ error: "Order not found" });
    if (!partner) return res.status(404).json({ error: "Partner not found" });
    if (order.status !== "ready_for_pickup") {
      return res.status(400).json({ error: "Order not ready for pickup" });
    }
    if (partner.status !== "available") {
      return res.status(400).json({ error: "Partner not available" });
    }

    const updatedOrder = await Order.findByIdAndUpdate(
      orderId,
      {
        deliveryPartner: partner._id,
        status: "out_for_delivery",
        deliveryStage: 6,
        deliveryStatus: "assigned",
        dispatchedAt: new Date()
      },
      { new: true }
    )
      .populate('deliveryPartner', 'name phone vehicleId status averageRating')
      .populate('userId', 'name phone')
      .populate('address');

    await DeliveryPartner.findByIdAndUpdate(
      deliveryPartnerId,
      {
        status: "assigned",
        assignedOrderId: order._id
      }
    );

    res.status(200).json({
      message: "Partner assigned successfully",
      order: updatedOrder
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};